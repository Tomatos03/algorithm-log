# [3607. 电网维护](https://leetcode.cn/problems/power-grid-maintenance/)

## 解题思路

1. 根据给定的连接关系数组$connections$建图
2. 遍历所有的连通块. 将属于通一个连通块的节点存放在同一个堆中, 并记录每一个节点属于哪一个堆.
3. 查询类型为$1$, 将对应的$x$添加到离线集合中; 查询类型为$2$, 如果$x$不属于离线集合, 则查询答案为$x$; 如果$x$属于离线集合则输出编号为$x$的电站所在堆的最小非离线电站编号(由于$1$类型操作添加了一些电站到离线集合, 在输出前需要将离线且位于堆顶的电站从堆中移除)

## 参考代码


```cpp
using i64 = long long;
using pii = pair<int, int>;
class Solution {
    void dfs(
        vector<bool> &vis,
        vector<vector<int>> &g,
        vector<int> &id,
        priority_queue<int, vector<int>, greater<int>> &pq,
        int num,
        int k
    ) {
        vis[k] = true;
        id[k] = num;
        pq.push(k);

        for (int &u : g[k]) {
            if (!vis[u])
                dfs(vis, g, id, pq, num, u);
        }
    }
public:
    vector<int> processQueries(int c, vector<vector<int>>& connections, vector<vector<int>>& queries) {
        vector<vector<int>> g(c + 1);
        for (vector<int> &connection : connections) {
            int u = connection[0], v = connection[1];
            g[u].push_back(v);
            g[v].push_back(u);
        }

        vector<bool> vis(c + 1);
        vector<int> id(c + 1);
        vector<priority_queue<int, vector<int>, greater<int>>> pqs;
        for (int i = 1; i <= c; ++i) {
            if (vis[i])
                continue;

            int num = pqs.size();
            priority_queue<int, vector<int>, greater<int>> pq;
            dfs(vis, g, id, pq, num, i);
            pqs.push_back(pq);
        }

        vector<int> ans;
        set<int> offline;
        for (vector<int> query : queries) {
            int type = query[0], value = query[1];
            int i = id[value];
            if (type == 2) {
                offline.insert(value);
            } else {
                if (!offline.count(value)) {
                    ans.push_back(value);
                    continue;
                }

                while (!pqs[i].empty() && offline.count(pqs[i].top()))
                    pqs[i].pop();

                ans.push_back(pqs[i].empty() ? -1 : pqs[i].top());
            }
        }
        return ans;
    }
};

```

