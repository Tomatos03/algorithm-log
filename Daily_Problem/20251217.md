# [3573. 买卖股票的最佳时机 V](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-v/)

## 解题思路

注意到原问题在确定了决策之后存在子问题:

1. 第$i$天不持有股票, 最大利润为以下情况的最值

   1. 不持有股票的情况下在$[i + 1, n]$之中购买股票能够得到的最大利润
   1. $-price[i]$(购入股票) + 买入股票待卖出的情况下在$[i + 1, n]$天中购买股票能够得到的最大利润
   1. $+price[i]$(卖出股票) + 卖出股票待回收的情况下在$[i + 1, n]$天中购买股票能够得到的最大利润
 2. 第$i$天持有某张股票待卖出(持有的股票在$i$天之前购入)
   1. 股票待卖出的情况下在$[i + 1, n]$天中购买股票能够得到的最大利润
   2. $+price[i]$(卖出股票) + 不持有股票的情况下在$[i + 1, n]$天中购买股票能够得到的最大利润
 3. 第$i$天某张股票待回收(在第$i$天之前卖出了某张股票)
   1. 股票待回收的情况下在$[i + 1, n]$天中购买股票能够得到的最大利润
   2. $-price[i]$(回收股票) + 不持有股票的情况下在$[i + 1, n]$天中购买股票能够得到的最大利润


```cpp
// 时间复杂度O(52n + m)
using i64 = long long;
class Solution {
    const i64 INF = -1e18;
public:
    long long maximumProfit(vector<int>& prices, int k) {
        i64 ans = 0;
        int n = prices.size();
        vector<vector<vector<i64>>> f(n, vector<vector<i64>>(k + 1, vector<i64>(3, INF)));
        // status = 0 没有持有股票, status = 1 持有股票待出售, status = 2 卖出股票待收回
        auto dfs = [&](auto &&dfs, int i, int status, int k) -> i64 {
            if (i == n || k == 0)
                return status == 2 ? INF / 2 : 0;

            if (f[i][k][status] != INF)
                return f[i][k][status];

            f[i][k][status] = 0;
            if (status == 0)
                return f[i][k][status] = max({
                    dfs(dfs, i + 1, 0, k),
                    dfs(dfs, i + 1, 1, k) - prices[i],
                    dfs(dfs, i + 1, 2, k) + prices[i]
                });
            if (status == 2)
                return f[i][k][status] = max(dfs(dfs, i + 1, 2, k), dfs(dfs, i + 1, 0, k - 1) - prices[i]);
            return f[i][k][status] = max(dfs(dfs, i + 1, 1, k), dfs(dfs, i + 1, 0, k - 1) + prices[i]);
        };
        return dfs(dfs, 0, 0, k);
    }
};

```

