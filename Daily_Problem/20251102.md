# [2257. 统计网格图中没有被保卫的格子数](https://leetcode.cn/problems/count-unguarded-cells-in-the-grid/)

## 解题思路

### 方法一

1. 遍历所有的守卫能够看到的位置, 遍历过程中如果遇到墙或者另一个守卫就停止遍历

 ### 方法二

1. 一个空格是否能够被守护取决于相邻方向上是否存在一个守卫(如果单个方向上存在多个就取最近的那一个)

## 参考代码


```cpp
\\ 时间复杂度O(nm)
using i64 = long long;
using pii = pair<int, int>;
class Solution {
public:
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        vector<vector<bool>> vis(m, vector<bool>(n)), occupy(m, vector<bool>(n));

        queue<pii> que;
        for (vector<int>& g : guards) {
            int x = g[0], y = g[1];
            que.push({x, y});
            vis[x][y] = true;
            occupy[x][y] = true;
        }

        for (vector<int> &g : walls) {
            int x = g[0], y = g[1];
            vis[x][y] = true;
            occupy[x][y] = true;
        }

        int dx[] = {0, 0, -1, 1}, dy[] = {1, -1, 0, 0};
        while (!que.empty()) {
            auto[x, y] = que.front();
            que.pop();

            for (int i = 0; i < 4; ++i) {
                int x0 = x + dx[i], y0 = y + dy[i];
                while (0 <= x0 && x0 < m && 0 <= y0 && y0 < n && !occupy[x0][y0]) {
                    vis[x0][y0] = true;
                    x0 += dx[i];
                    y0 += dy[i];
                }
            }
        }
        int cnt = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                cnt += !vis[i][j];
            }
        }
        return cnt;
    }
};

```

```cpp
\\ 时间复杂度O(nmlog(max(n, m)))
using i64 = long long;
using pii = pair<int, int>;
class Solution {
public:
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        set<pii> st0, st1;

        vector<vector<int>> row(m), col(n);
        for (vector<int> &g : guards) {
            int x = g[0], y = g[1];
            row[x].push_back(y);
            col[y].push_back(x);
            st0.insert({x, y});
        }

        for (vector<int> &w : walls) {
            int x = w[0], y = w[1];
            row[x].push_back(y);
            col[y].push_back(x);
            st1.insert({x, y});
        }
        for (int i = 0; i < m; ++i) {
            sort(row[i].begin(), row[i].end());
        }
        for (int i = 0; i < n; ++i) {
            sort(col[i].begin(), col[i].end());
        }

        int cnt = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (st1.count({i, j}) || st0.count({i, j})) {
                    continue;
                }

                int p1 = lower_bound(row[i].begin(), row[i].end(), j) - row[i].begin();
                int p2 = lower_bound(row[i].begin(), row[i].end(), j) - row[i].begin() - 1;

                int p3 = lower_bound(col[j].begin(), col[j].end(), i) - col[j].begin();
                int p4 = lower_bound(col[j].begin(), col[j].end(), i) - col[j].begin() - 1;

                if ((p1 < row[i].size() && st0.count({i, row[i][p1]}))
                    || (p2 >= 0 && st0.count({i, row[i][p2]}))
                    || (p3 < col[j].size() && st0.count({col[j][p3], j}))
                    || (p4 >= 0 && st0.count({col[j][p4], j}))
                ) {
                    continue;
                }
                ++cnt;
            }
        }
        return cnt;
    }
};

```

