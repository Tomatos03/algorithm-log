# [1625. 执行操作后字典序最小的字符串](https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/)

## 解题思路

1. 使用BFS枚举所有可能的制造的字符串, 取其中最小的字符串

1. 最大状态数理论上限为$10 \times 10 \times s.length$, 其中$s.length$是字符串的长度

   **注:** 这里解释一下理论上限之中的三个数分别表示奇数位上的累加, 偶数位上的累加, 轮转次数. 当一个数字轮转到某个位置的时候, 奇数位上可能轮转了$[0, 9]$次, 偶数位置上也可能轮转了$[0, 9]$次

+ 时间复杂度$O(n * 10 * 10)$


```cpp
using i64 = long long;
class Solution {
    void op1(string &s, int a) {
        int n = s.size();
        for (int i = 1; i < n; i += 2) {
            int v = s[i] - '0';
            s[i] = char('0' + (v + a) % 10);
        }
    }

    void op2(string &s, int b) {
        int n = s.size();
        string r = s;
        for (int i = 0; i < n; ++i) {
            s[(i + b) % n] = r[i];
        }
    }
public:
    string findLexSmallestString(string s, int a, int b) {
        int n = s.size();

        string ans = s;
        unordered_set<string> st;
        queue<string> que;

        que.push(s);
        st.insert(s);
        while (!que.empty()) {
            string x = que.front(); que.pop();
            ans = min(ans, x);

            string y = x;
            op1(y, a);
            
            if (!st.count(y)) {
                que.push(y);
                st.insert(y);
            }

            op2(x, b);
            if (!st.count(x)) {
                que.push(x);
                st.insert(x);
            }
        }
        return ans;
    }
};

```
