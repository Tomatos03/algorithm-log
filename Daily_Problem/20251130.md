# [1590. 使数组和能被 P 整除](https://leetcode.cn/problems/make-sum-divisible-by-p/)

## 解题思路

1. 如果数组的和能够被$p$整除,不需要删除任何子数组. 否则必须删除一个子数组才有可能被$p$整除
1. 在确定必须删除一个子数组的情况下有如下公式:

$$
[pre[n] - (pre[r] - pre[l - 1])] \% p = 0 \rightarrow (pre[n] + pre[l - 1]) \% p = pre[r] \% p
$$



## 参考代码


```cpp
// 时间复杂度O(n)
using i64 = long long;
class Solution {
public:
    int minSubarray(vector<int>& nums, int p) {
        int n = nums.size();
        vector<i64> pre(n + 1, 0);
        for (int i = 0; i < n; ++i) {
            pre[i + 1] = pre[i] + nums[i];
        }
        if (pre[n] % p == 0)
            return 0;

        // pre[n] % p = (pre[r + 1] - pre[l]) % p
        // pre[n] % p + pre[l] % p = pre[r + 1] % p
        int r = pre[n] % p, ans = INT_MAX;
        map<int, int> mod_mp;
        mod_mp[r] = -1;
        for (int i = 0; i < n; ++i) {
            int cur_r = pre[i + 1] % p;
            if (mod_mp.count(cur_r)) {
                ans = min(ans, i - mod_mp[cur_r]);
            }
            mod_mp[(r + cur_r) % p] = i;
        }
        return (ans == INT_MAX || ans == n) ? -1 : ans;
    }
};

```

