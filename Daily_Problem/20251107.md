# [2528. 最大化城市的最小电量](https://leetcode.cn/problems/maximize-the-minimum-powered-city/)

## 解题思路

1. 本题需要最大化最小值,  如果一个电量值$v$是满足题目条件的, 那么所有$v_0 < v$的电量也必然满足条件. 所求答案具有明显的边界性. 考虑使用二分答案, 思考如何设计$check$函数
2. check函数的设计: 对于城市$i$, 需要知道当前能够产生多少电量, 如果达不到要求的最小电量$mi\_v$, 此时需要额外建立一些电站, 由于一个电站能够让$[i - r, i + r]$的位置都增加单位$1$的电量, 并且在判断城市$i$是否能够达到要求的电量时是顺序遍历的,  所以仅需要将$[i, i + 2r]$位置上的城市都增加单位$1$的电量即可(这里用到了贪心思想)
3. 对一个区间加上同一个数, 可以考虑使用差分数组的技巧

## 参考代码


```cpp
\\ 时间复杂度O(nlogn)
using i64 = long long;
using pii = pair<int, int>;
class Solution {
    const int inf = 1e5;
    bool check(vector<i64> d, int k, int r, i64& v) {
        int n = d.size();
        for (int i = 1; i < n - 1; ++i) {
            d[i] += d[i - 1];
            if (d[i] < v) {
                i64 need = v - d[i];
                if (k < need)
                    return false;

                k -= need;
                d[i] += need;
                d[min(i + 2 * r + 1, n - 1)] -= need;
            }
        }
        return true;
    }
public:
    long long maxPower(vector<int>& stations, int r, int k) {
        int n = stations.size();
        stations.insert(stations.begin(), -1);
        vector<i64> d(n + 2);
        for (int i = 1; i <= n; ++i) {
            d[max(0, i - r)] += stations[i];
            d[min(n + 1, i + r + 1)] -= stations[i];
        }

        i64 l0 = 0, r0 = LLONG_MAX / 2;
        while (l0 < r0) {
            i64 mid = (l0 + r0 + 1) >> 1;
            if (check(d, k, r, mid)) {
                l0 = mid;
            } else {
                r0 = mid - 1;
            }
        }
        return l0;
    }
};


```

