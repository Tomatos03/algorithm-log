# [3756. 连接非零数字并乘以其数字和 II](https://leetcode.cn/problems/concatenate-non-zero-digits-and-multiply-by-sum-ii/)

## 解题思路

1. 去除字符串$s$之中所有的$0$, 然后按顺序连接剩余字符. 让$str$表示新得到的字符串
2. 在得到$str$时, 需要记录str的每一个字符在原字符串之中的位置, 让$ids$表示这个数组
3. 对于一个查询$[queries[i][0], queries[i][1]]$,  可以直接通过对$ids$数组进行二分查找定位不包含$0$的字符串
4. 由于查询数组最大长度为$10^5$, 考虑对$str$预处理以下几个数组:
   1. 前缀和数组$pre$
   1. 满足表达式$(x \times 10 + (str[i] - '0')) \% mod$的前缀和数组$pre\_p$
   1. 10的幂取余$m$结果数组$pow\_10$
5. 一个数字字符串中的任意子串转数字后取余$m$的结果可以由以下公式计算:

$$
(pre\_p[r] - pre\_p[l - 1] \times pow\_10[r - l + 1] + m) \% m
$$



## 参考代码


```cpp
// 时间复杂度O(size(queries) * logn)
using i64 = long long;
class Solution {
    const int mod = 1e9 + 7;
public:
    vector<int> sumAndMultiply(string s, vector<vector<int>>& queries) {
        int len = s.size();
        string str = "";
        vector<int> ids;
        for (int i = 0; i < len; ++i) {
            char c = s[i];
            if (c != '0') {
                str.push_back(c);
                ids.push_back(i);
            }
        }

        len = str.size();
        int size = queries.size();
        vector<i64> pre(len + 1, 0), pre_p(len + 1, 0), pow_10(len + 1, 1);
        for (int i = 0; i < len; ++i) {
            int num = str[i] - '0';
            pre[i + 1] = pre[i] + num;
            pre_p[i + 1] = (pre_p[i] * 10 % mod  + num) % mod;
            pow_10[i + 1] = (pow_10[i] * 10) % mod;
        }

        vector<int> ans(size, 0);
        for (int i = 0; i < size; ++i) {
            int l = queries[i][0], r = queries[i][1];
            l = lower_bound(ids.begin(), ids.end(), l) - ids.begin();
            r = upper_bound(ids.begin(), ids.end(), r) - ids.begin() - 1;
            if (l <= r) {
                int sum = (pre[r + 1] - pre[l]) % mod;
                int x = (pre_p[r + 1] - pre_p[l] * pow_10[r - l + 1] % mod + mod) % mod;
                ans[i] = 1LL * x * sum % mod;
            }
        }
        return ans;
    }
};

```

