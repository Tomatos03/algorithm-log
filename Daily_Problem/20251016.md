# [2598. 执行操作后的最大 MEX](https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/)

## 解题思路

1. 注意到总是能够通过添加$k$次$value$让数组中的数$nums[i]$变为$nums[i] \% value$
1. 将原数组的$nums[i]$替换成$nums[i] \% value$
1. 对于输入数组最大的$MEX$就是数组的长度$n$
1. 顺序检查$[0, n - 1]$是否有数, 当遍历到$i$时, 如果能够通过操作变成$i$的数不止一个, 此时将多余的数从$i \rightarrow i + value$ , 如果$i + value \geq n$, 就没有必要进行这操作, 因为$MEX \leq n$

## 参考代码

+ 时间复杂度$O(n)$


```cpp
class Solution {
public:
    int findSmallestInteger(vector<int>& nums, int value) {
        int n = nums.size();
        unordered_map<int, int> mp;
        for (int &v : nums) {
            int r = ((v % value) + value) % value;
            mp[r]++;
        }
        for (int i = 0; i < n; ++i) {
            if (!mp.count(i)) {
                return i;
            } else {
                if (i + value < n && mp[i] > 1)
                    mp[i + value] = mp[i] - 1;
            }
        }
        return n;
    }
};
```
