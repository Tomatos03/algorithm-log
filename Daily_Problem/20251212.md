# [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

## 解题思路

1. 注意到如果确定其中一条线的高度$h_i$, 并且另一条线的高度为$h_j \ge h_i$, 那么$h_j$在输入数组中的位置与$h_i$在输入数组中的位置距离越远越好
1. 根据$1$的分析, 在遍历过程中可以维护第一个递增序列, 当遍历到$i$时, 查找$[1, i - 1]$维护的递增序列中第一个$\ge height[i]$的位置, 然后计算此时可以存储的最大水量
1. 需要遍历两次原数组, 第一次正序, 第二次反序, 否测会漏掉一些情况

## 参考代码


```cpp
// 时间复杂度O(nlogn)
class Solution {
    int cal(int l, int r, int h) {
        return (r - l) * h;
    }
public:
    int getMaxArea(vector<int> &height) {
        int n = height.size(), ans = 0;
        vector<int> ids;
        for (int i = 0; i < n; ++i) {
            int pos = lower_bound(
                ids.begin(), ids.end(), height[i],
                [&](int idx, int val) { return height[idx] < val; }
            ) - ids.begin();

            if (pos < ids.size())
                ans = max(ans, cal(ids[pos], i, height[i]));

            if (ids.empty() || height[i] > height[ids.back()])
                ids.push_back(i);
        }
        return ans;
    }
    int maxArea(vector<int>& height) {
        vector<int> h_rev = height;
        reverse(h_rev.begin(), h_rev.end());
        return max(getMaxArea(height), getMaxArea(h_rev));
    }
};

```

