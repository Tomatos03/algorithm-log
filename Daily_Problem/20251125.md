# [1015. 可被 K 整除的最小整数](https://leetcode.cn/problems/smallest-integer-divisible-by-k/)

## 解题思路

1. 注意到: $1111 = 111 * 10 + 1$, 所以有$v_i = v_{i - 1} * 10 + 1  \rightarrow v_i \% k = ((v_{i - 1} * 10) \% k + 1) \%k$
2. 从$1$开始逐渐增加$n$的长度, 记录每一次取余$k$的结果, 如果当前余数$r$在之前已经计算过了, 说明进入了一个循环, 不存在一个能够被$k$整除的$n$.
3. 取余$k$至多有$k$个结果, 由抽屉原理可知最多计算$k$次余数, 如果$k$次后还没有满足条件的$n$, 那么之后必然不存满足条件的$n$

## 参考代码


```cpp
// 时间复杂度O(k)
class Solution {
public:
    int smallestRepunitDivByK(int k) {
        int len = 1, pre_r = 0;
        set<int> st;
        while (true) {
            int r = (pre_r * 10 + 1) % k;
            if (r == 0)
                return len;
            if (st.count(r))
                break;
            st.insert(r);
            pre_r = r;
            ++len;
        }
        return -1;
    }
};
```

