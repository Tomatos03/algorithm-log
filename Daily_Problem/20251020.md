# [164. 最大间距](https://leetcode.cn/problems/maximum-gap/)

## 解题思路

1. 考虑一种相邻元素的特殊情况, 每一个元素之间的间距都是相等的, 此时元素的最大间距$mx\_d = d, averge\_d = d$其中$averge\_d$表示平均距离
1. 移动其中一个元素, 直觉上可以发现元素最大间距变大, 尝试猜想相邻元素之间的最大间距$mx\_d \ge averge\_d$, 其中$averge\_d = \frac{mx - mi}{n - 1}$
1. 将区间$[mx, mi]$划分为$n - 1$个区间, 数组中的每一个数都对应其中一个区间, 计算公式为$\frac{nums[i] - mi}{n - 1}$, 对于相同区间的相邻数间距不可能是最大间距, 最大间距只可能出现在相邻区间之间, 
1. 两个相邻的区间的相邻数相邻值$=$ 第二个区间中的最小数 $-$ 第一个区间中的最大数

对于$2$的证明:

假设原数组$nums$已经从小到大排序, $nums_1... nums_{n}$, 则有:

$$
nums_n - nums_1 = \sum_{2}^{n}{nums_i - nums_{i - 1}} \le mx\_d \times (n - 1) \\
mx\_d \ge \frac{nums_n - nums_1}{n - 1} = averge\_d
$$

## 参考代码

+ 时间复杂度$O(n)$


```cpp
using i64 = long long;
using pii = pair<int, int>;
class Solution {
public:
    int maximumGap(vector<int>& nums) {
        int n = nums.size(), ans = 0;
        if (n == 1)
            return 0;

        int mx = INT_MIN, mi = INT_MAX;
        for (int &v : nums) {
            mx = max(mx, v);
            mi = min(mi, v);
        }
		// (mx - mi)不总是能够整除(n - 1), 这里向上取整
        // 向上取证会让平均间距变大, 由于mx_d是整数, 此时必然有mx_d - floor(averge_d) >= 1
        // 其中floor(x)表示x的向下取证
        int d = (mx - mi + n - 2) / (n - 1); 
        vector<vector<int>> b(n);
        for (int i = 0; i < n; ++i) {
            b[i] = {INT_MAX, INT_MIN};
        }

        for (int i = 0; i < n; ++i) {
            int pos = (nums[i] - mi) / d;
            b[pos][0] = min(b[pos][0], nums[i]);
            b[pos][1] = max(b[pos][1], nums[i]);
        }

        int pre_mx = -1;
        for (int i = 0; i < n; ++i) {
            if (b[i][0] == INT_MAX)
                continue;

            if (pre_mx != -1)
                ans = max(ans, b[i][0] - pre_mx);
            pre_mx = b[i][1];
        }
        return ans;
    }
};

```

