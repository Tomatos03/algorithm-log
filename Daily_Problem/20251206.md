# [3578. 统计极差最大为 K 的分割方式数](https://leetcode.cn/problems/count-partitions-with-max-min-difference-at-most-k/)

## 解题思路

1. 注意到确定一个从数组起始开始的分割之后问题可以转换数组去除这个分割之后的新数组有多少个满足条件的分割数
1. 尝试使用记忆化$dfs$实现$1$的想法, 时间复杂度为$O(n^2)$, 不能够通过本地, 但又注意到$dfs$过程中存在大量重复计算:

$$
dfs(i) = dfs(i + 1) + dfs(i + 2) \cdots dfs(j) \\
dfs(i + 1) = dfs(i + 2) \cdots dfs(j) \\
\cdots \\
其中j表示[i, j]中第一个满足max(nums[i]\cdots nums[j]) - min(nums[i] \cdots nums[j]) > k的位置
$$

3. 重复计算可以通过记录后缀解决. 预处理出数组$right$, 其中$right[i] = j$, 满足性质$j$是$[i, j]$中第一个 $max(nums[i]\cdots nums[j]) - min(nums[i] \cdots nums[j]) > k$的位置



## 参考代码


```cpp
// 时间复杂度O(n)
using i64 = long long;
class Solution {
    const int mod = 1e9 + 7;
public:
    int countPartitions(vector<int>& nums, int k) {
        int n = nums.size(), cnt = 1;
        vector<int> right(n, 0);
        deque<int> mi_que, mx_que;
        for (int i = 0, r = 0; i < n; ++i) {
            while (r < n) {
                while (!mi_que.empty() && nums[mi_que.back()] > nums[r])
                    mi_que.pop_back();
                while (!mx_que.empty() && nums[mx_que.back()] < nums[r])
                    mx_que.pop_back();

                mi_que.push_back(r);
                mx_que.push_back(r);
                if (nums[mx_que.front()] - nums[mi_que.front()] > k) {
                    if (mx_que.back() == r)
                        mx_que.pop_back();
                    if (mi_que.back() == r)
                        mi_que.pop_back();
                    break;
                }

                ++r;
            }
            right[i] = r;

            if (!mi_que.empty() && mi_que.front() == i)
                mi_que.pop_front();
            if (!mx_que.empty() && mx_que.front() == i)
                mx_que.pop_front();
        }

        vector<int> f(n + 1, 0), suffix(n + 2, 0);
        suffix[n] = 1;
        for (int i = n - 1; i >= 0; --i) {
            f[i] = (suffix[i + 1] - suffix[right[i] + 1] + mod) % mod;
            suffix[i] = (suffix[i + 1] + f[i]) % mod;
        }
        return f[0];
    }
};

```

