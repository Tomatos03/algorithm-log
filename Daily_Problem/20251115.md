# [3234. 统计 1 显著的字符串的数量](https://leetcode.cn/problems/count-the-number-of-substrings-with-dominant-ones/)

## 解题思路

1. 枚举子串的右端点, 对于一个确定的右端点, 计算所有满足条件的左端点
2. $1$显著字符串长度不能够超过枚举的最大子串$(1\dots r)$的长度$r$, 所以必须满足$zero^2 + zero \le r$, 其中$zero$表示子串中$0$的数量
3. 在固定了右端点$r$后, 还需要枚举左端点$l$, 第二点的性质并不能够降低复杂度, 这里考虑预处理一个$pre$数组, 满足以$i$为右端点向左扩展有多少个连续$1$, 在枚举左端点$l$的过程中如果是$1$, 可以直接移动到下一个不为$1$的位置$l - pre[l]$, 如果是$0$当前$l$减少$1$
4. 对于$3$中分析的两种情况对总计数$cnt$的贡献: 
   1. $s[l] = 1$, $cnt = \max(\min(r - l - zero * zero - zero + 1, pre_l - l), 0)$
   2. $s[l] = 0 \and r - l \ge zero^ 2 + zero$,  $cnt = cnt + 1$


## 参考代码


```cpp
using i64 = long long;
using pii = pair<int, int>;
class Solution {
public:
    int numberOfSubstrings(string s) {
        int n = s.size(), cnt = 0;
        s = '@' + s;
        vector<int> pre(n + 1);
        for (int i = 1; i <= n; ++i) {
            int v = s[i] - '0';
            if (v) {
                pre[i] = pre[i - 1] + v;
            }
        }

        for (int r = 1; r <= n; ++r) {
            int zero = 0, l = r;
            while (zero * zero + zero <= r && l >= 1) {
                int v = s[l] - '0';

                int pre_l = l;
                if (v) {
                    l = max(0, l - pre[l]);
                    int w = min(r - l - zero * zero - zero + 1, pre_l - l);
                    cnt += max(0, w);
                } else {
                    --l;
                    ++zero;
                    cnt += r - l - zero >= zero * zero;
                }
            }
        }
        return cnt;
    }
};

```

