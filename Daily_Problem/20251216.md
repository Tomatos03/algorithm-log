# [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

## 解题思路

1. 从$s$之中选择的子串$x$满足$t$中的每种字符都在$x$中出现, 并且数量$\le$ $x$中这种字符出现的数量
1. 顺序遍历子串右端点, 如果存在满足条件的子串左端点, 选择最靠近右端点的那个点.
1. 子串$x$的右端点和左端点的字符一定存在与$t$字符串中, 编译过程中可以直接忽略不在$t$字符串中的字符



```cpp
// 时间复杂度O(52n + m)
class Solution {
    int index(char &c) {
        return 'a' <= c && c <= 'z' ? (c - 'a') : (c - 'A') + 26;
    }

public:
    string minWindow(string s, string t) {
        int n = s.size(), m = t.size();
        vector<int> need(52);
        for (char &c : t) {
            int k0 = index(c);
            need[k0]++;
        }

        string ans = "";
        deque<int> que;
        vector<int> cnt(52);
        for (int i = 0; i < n; ++i) {
            int k = index(s[i]);
            if (need[k] == 0)
                continue;

            ++cnt[k];
            que.push_back(i);
            bool ok = true;
            for (int j = 0; j < 52; ++j) {
                ok &= (cnt[j] >= need[j]);
            }
            if (!ok)
                continue;
            int p = index(s[que.front()]);
            while (cnt[p] - 1 >= need[p]) {
                --cnt[p];
                que.pop_front();
                p = index(s[que.front()]);
            }

            if (ans == "" || i - que.front() + 1 < ans.size())
                ans = s.substr(que.front(), i - que.front() + 1);
        }
        return ans;
    }
};

```

