# [2141. 同时运行 N 台电脑的最长时间](https://leetcode.cn/problems/maximum-running-time-of-n-computers/)

## 解题思路

1. 如果能够同时运行$n$台电脑$t$秒, 那么运行$t_0 < t$秒也必然是可行的
1. 对于一个确定的时间$t$, 只需要判断$n$台电脑的运行时间是否能够凑满$t$秒
1. 将原输入数组从大到小排序, 每当确认一个时间$t$时, 取数组前$n$个数为这$n$个电脑的初始电量, 数组后续$size - n$个数作为这$n$个电池的补充, 如果能够让这$n$个电池凑满电量$t$, 那么当前时间$t$, 就是能够满足的运行时间



## 参考代码


```cpp
// 时间复杂度O(nlogn)
using i64 = long long;
class Solution {
    vector<int> b;
    int n;

    bool check(i64 t) {
        vector<i64> f(b.begin(), b.begin() + n);

        int size = b.size(), j = 0;
        while (j < n && f[j] >= t)
            ++j;

        i64 pre_w = 0;
        for (int i = n; i < size && j < n; ++i) {
            i64 v0 = min(pre_w + b[i], t - f[j]);
            f[j] += v0;
            pre_w = pre_w + b[i] - v0;

            if (f[j] == t)
                ++j;
        }
        while (j < n && pre_w > 0) {
            i64 v0 = min(pre_w, t - f[j]);
            f[j] += v0;
            pre_w -= v0;

            if (f[j] == t)
                ++j;
        }
        return j == n;
    }

public:
    long long maxRunTime(int n, vector<int>& batteries) {
        this->n = n;
        b = batteries;
        sort(b.begin(), b.end(), greater<int>());

        i64 l = 1, r = LLONG_MAX / 2;
        while (l < r) {
            i64 mid = (l + r + 1) >> 1;
            if (check(mid))
                l = mid;
            else
                r = mid - 1;
        }
        return l;
    }
};


```

