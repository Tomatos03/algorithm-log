# [2872. 可以被 K 整除连通块的最大数目](https://leetcode.cn/problems/maximum-number-of-k-divisible-components/)

## 解题思路

1. 题设并没有明确当前树的根节点, 可以选择任意一个节点作为根节点, 这里选择编号为$0$的节点作为根节点
1. 注意到一个叶子节点的值如果不能够被$k$整除, 那么这个叶子节点必然和其父节点属于同一个连通块. 此时又可以将这个节点的父节点和其不能够被$k$整除的节点当成一个新节点, 新的节点值为父节点的值 + 父节点的子节点中不能够被$k$整除的所有子节点的值的和
1. 至底向上计算, 如果当前累计的$value$能够被$k$整除就划分出一个新的连通块. 由于所有节点值的和总是能够被$k$整除的, 这样的划分最后一定是一个"合格的分割"

## 参考代码


```cpp
// 时间复杂度O(n)
using i64 = long long;
class Solution {
    vector<vector<int>> g;
    vector<int> values;
    int size, k, ans = 0;

    i64 dfs(int i, int p_i) {

        i64 sum = values[i];
        for (int &j : g[i]) {
            if (j != p_i) {
                sum += dfs(j, i);
            }
        }
        if (sum % k == 0) {
            ++ans;
            return 0;
        }
        return sum;
    }

public:
    int maxKDivisibleComponents(int n, vector<vector<int>>& edges, vector<int>& values, int k) {
        this->size = n;
        this->values = values;
        this->k = k;
        g = vector<vector<int>>(n);

        for (vector<int> &e : edges) {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }
        dfs(0, -1);
        return ans;
    }
};
```

