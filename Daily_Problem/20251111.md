# [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

## 解题思路

1. 从数组的最左边的数开始考虑, 如果选择这个数原问题最多有$m$个0, $n$个$1$ 变为$m - cnt[0]$个0, $n - cnt[1]$个$1$能得到的最大子集长度加$1$; 不选择这个数原问题不变, 但数据范围变小(最左边的数不选)

2. 经过$1$的分析知道原问题存在子问题, 可以记忆化(需要考虑在数组中不同位置的$n$和$m$)

    

## 参考代码


```cpp
// 时间复杂度O(n * m * len(strs) * len(strs[i]))
// 预处理字符串长度可以将复杂度降低到O(n * m * len(strs))
using i64 = long long;
using pii = pair<int, int>;
class Solution {
    vector<string> strs;
    vector<vector<vector<int>>> memo;
    int size;

    int dfs(int k, int cnt_one, int cnt_zero) {
        if (k == size) {
            return 0;
        }

        int &max_len = memo[k][cnt_one][cnt_zero];
        if (max_len != 0) {
            return max_len;
        }

        int cnt[2] = {0, 0};
        for (char c : strs[k]) {
            int v = c - '0';
            cnt[v]++;
        }

        max_len = dfs(k + 1, cnt_one, cnt_zero);
        if (cnt_one >= cnt[1] && cnt_zero >= cnt[0]) {
            max_len = max(max_len, dfs(k + 1, cnt_one - cnt[1], cnt_zero - cnt[0]) + 1);
        }

        return max_len;
    }

public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        this->strs = strs;
        this->size = strs.size();
        memo = vector<vector<vector<int>>>(size, vector<vector<int>>(n + 1, vector<int>(m + 1, 0)));

        return dfs(0, n, m);
    }
};

```

