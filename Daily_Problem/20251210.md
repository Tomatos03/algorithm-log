# [3577. 统计计算机解锁顺序排列数](https://leetcode.cn/problems/count-the-number-of-computer-unlocking-permutations/)

## 解题思路

1. 编号为0的计算机的密码复杂度必须是唯一最低的且位于数组之中第一个位置, 否则将无法解锁所有的计算机密码
1. 满足$1$分析之中的条件之后, 剩下的位置能够任意排列, 不受限制. 排列数为$(size - 1) \times (size - 2), 其中size表示输入数组的大小$, 

## 参考代码


```cpp
// 时间复杂度O(n)
using i64 = long long;
class Solution {
    const int mod = 1e9 + 7;
public:
    int countPermutations(vector<int>& complexity) {
        int mi = INT_MAX;
        int size = complexity.size();
        for (int i = 0; i < size; ++i) {
            mi = min(mi, complexity[i]);
        }
        if (complexity[0] != mi)
            return 0;
        for (int i = 1; i < size; ++i) {
            if (complexity[i] == mi)
                return 0;
        }
            
        i64 cnt = 1;
        for (int i = 1; i <= size - 1; ++i) {
            cnt = (cnt * i) % mod;
        }
        return int(cnt);
    }
};

```

