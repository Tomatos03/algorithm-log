# [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

## 解题思路

1. 注意到以两个节点的公共祖先为根节点的二叉树, 必然包含这两个节点. 当利用dfs进行遍历的时候, 如果当前遍历节点值等于输入两个节点值的其中一个, 那么累计返回值为1. 当累计的返回值达到2, 那么这个点必然是输入两个点的公共祖先, 第一个累计到2的遍历节点位置, 就是最近公共祖先节点.

## 参考代码


```cpp
// 时间复杂度O(二叉树节点数量)
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        int x = p->val, y = q->val;
        TreeNode *ans = nullptr;
        auto dfs = [&](auto &&dfs, TreeNode* cur) -> int {
            int cnt = (cur->val == x) || (cur->val == y);
            if (cur->left != nullptr)
                cnt += dfs(dfs, cur->left);
            if (cur->right != nullptr)
                cnt += dfs(dfs, cur->right);

            if (ans == nullptr && cnt == 2)
                ans = cur;
            return cnt;
        };
        dfs(dfs, root);
        return ans;
    }
};


```

