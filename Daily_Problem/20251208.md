# [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

## 解题思路

1. 最简单的实现就是将输入数组排序, 然后顺序查找第一个缺失的正数, 此算法时间复杂度为$O(n\log{n})$
1. 进一步的实现是利用一个$vector$数组当桶, 桶大小设置为输入数组大小加上$2$,  统计输入数组数的出现次数, 然后进行顺序查找. 时间复杂度$O(n)$, 空间复杂度为$O(n)$
1. 利用将输入的$nums$数组当成桶来使用, 对于一个数$nums[i]$, 在桶之中的位置为$nums[nums[i] - 1], 1 \le nums[i] \le n$.  如果直接顺序遍历存在一种特殊情况当$nums[i]$放到对应的$j$位置上时, $i$位置上是$nums[j]$, 如果有$nums[j] < nums[i]$, 那么$nums[j]$会被跳过, 遍历完整个数组之后$nums[j]$没有放在正确的位置上.
1. 对于$3$中的特殊情况只需要在交换$(i, j)$位置之后, 如果仍然满足$nums[nums[i] - 1] \ne nums[i] \and i + 1 \ne nums[i]$就继续进行交换, 这种至多进行$n$次

## 参考代码


```cpp
// 时间复杂度O(n)
using i64 = long long;
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            while (
                1 <= nums[i] && nums[i] <= n
                && (i + 1 != nums[i])
                && (nums[nums[i] - 1] != nums[i])
            ) {
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1)
                return i + 1;
        }
        return n + 1;
    }
};
```

